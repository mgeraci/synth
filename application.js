// Generated by CoffeeScript 2.2.3
(function() {
  var controlWatchers, init, keyboard, note, noteOff, noteOn, oscillator, setDefaults;

  $(function() {
    return init();
  });

  init = function() {
    var error;
    try {
      this.context = new (window.AudioContext || window.webkitAudioContext);
    } catch (error1) {
      error = error1;
      alert('Web Audio API is not supported in your browser');
    }
    if (this.context) {
      oscillator();
      controlWatchers();
      setDefaults();
      return keyboard();
    }
  };

  controlWatchers = function() {
    $('#attack').on('change', (e) => {
      return this.a = (500 * $(e.target).val()) / 100;
    });
    $('#decay').on('change', (e) => {
      return this.d = (500 * $(e.target).val()) / 100;
    });
    $('#sustain').on('change', (e) => {
      return this.s = (500 * $(e.target).val()) / 100;
    });
    $('#release').on('change', (e) => {
      return this.r = (500 * $(e.target).val()) / 100;
    });
    $('#sustain-level').on('change', (e) => {
      return this.sl = $(e.target).val() / 100;
    });
    return $('#wave').on('change', (e) => {
      var span, wave;
      span = $(e.target).siblings('span');
      switch (parseInt($(e.target).val())) {
        case 0:
          wave = 0;
          span.text('sine');
          break;
        case 25:
          wave = 1;
          span.text('square');
          break;
        case 50:
          wave = 2;
          span.text('saw');
          break;
        case 75:
          wave = 3;
          span.text('triangle');
      }
      return this.osc.type = wave;
    });
  };

  // set defaults for the parameters
  setDefaults = function() {
    $('#attack').val(5).trigger('change');
    $('#decay').val(20).trigger('change');
    //$('#sustain').val(100).trigger('change')
    $('#release').val(60).trigger('change');
    return $('#sustain-level').val(50).trigger('change');
  };

  // create an oscillator, connect it, and turn it on
  oscillator = function() {
    this.output = 0; // let's start the output at 0
    this.osc = this.context.createOscillator();
    this.gainnode = this.context.createGainNode();
    this.osc.connect(this.gainnode);
    this.gainnode.gain.value = 0;
    this.gainnode.connect(context.destination); // Connect to speakers
    this.osc.noteOn(0); // Start generating sound immediately
    return this.osc.frequency.value = 500;
  };

  // set the frequency and trigger the attack
  note = function(freq) {
    this.osc.frequency.value = freq;
    return noteOn();
  };

  // trigger the attack and decay of a note
  noteOn = function() {
    var aNumberOfSteps, aSizeOfSteps, dNumberOfSteps, dSizeOfSteps, i, j, ref;
    this.grain = 1; // frequency of steps
    if (this.aInnerTimeout != null) {
      
      // clear any timeouts that exist from other notes
      clearTimeout(this.aInnerTimeout);
    }
    if (this.dTimeout != null) {
      clearTimeout(this.dTimeout);
    }
    if (this.dInnerTimeout != null) {
      clearTimeout(this.dInnerTimeout);
    }
    if (this.rInnerTimeout != null) {
      clearTimeout(this.rInnerTimeout);
    }
    if (this.endTimeout != null) {
      clearTimeout(this.endTimeout);
    }
    // you should get from start to end in a ms, with steps of @grain
    aNumberOfSteps = this.a / this.grain;
    aSizeOfSteps = (1 - this.output) / aNumberOfSteps;
    dNumberOfSteps = this.d / this.grain;
    dSizeOfSteps = (1 - this.sl) / dNumberOfSteps;
// attack
    for (i = j = 0, ref = aNumberOfSteps; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this.aInnerTimeout = setTimeout(() => {
        this.output += aSizeOfSteps;
        return this.gainnode.gain.value = this.output;
      }, i * this.grain);
    }
    // decay
    return this.dTimeout = setTimeout(() => {
      var l, ref1, results;
      results = [];
      for (i = l = 0, ref1 = dNumberOfSteps; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
        results.push(this.dInnerTimeout = setTimeout(() => {
          this.output -= dSizeOfSteps;
          return this.gainnode.gain.value = this.output;
        }, i * this.grain));
      }
      return results;
    }, this.a);
  };

  // trigger the decay
  noteOff = function() {
    var i, j, rNumberOfSteps, rSizeOfSteps, ref;
    if (this.aInnerTimeout != null) {
      // clear any timeouts that exist from other notes
      clearTimeout(this.aInnerTimeout);
    }
    if (this.dTimeout != null) {
      clearTimeout(this.dTimeout);
    }
    if (this.dInnerTimeout != null) {
      clearTimeout(this.dInnerTimeout);
    }
    if (this.rInnerTimeout != null) {
      clearTimeout(this.rInnerTimeout);
    }
    if (this.endTimeout != null) {
      clearTimeout(this.endTimeout);
    }
    rNumberOfSteps = this.r / this.grain;
    rSizeOfSteps = this.sl / rNumberOfSteps;
// release
    for (i = j = 0, ref = rNumberOfSteps; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this.rInnerTimeout = setTimeout(() => {
        this.output -= rSizeOfSteps;
        return this.gainnode.gain.value = this.output;
      }, i * this.grain);
    }
    // and set to 0 at the end
    return this.endTimeout = setTimeout(() => {
      this.output = 0;
      return this.gainnode.gain.value = this.output;
    }, this.r + this.grain * 2);
  };

  // bind keys to frequencies using mousetrap
  keyboard = function() {
    var notes;
    // map a key with a frequency
    notes = [['z', 523.25], ['s', 554.37], ['x', 587.33], ['d', 622.25], ['c', 659.26], ['v', 698.46], ['g', 739.99], ['b', 783.99], ['h', 830.61], ['n', 880], ['j', 932.33], ['m', 987.77], [',', 1046.5], ['l', 1108.73], ['.', 1174.66], [';', 1244.51], ['/', 1318.51], ['q', 1046.5], ['2', 1108.73], ['w', 1174.66], ['3', 1244.51], ['e', 1318.51], ['r', 1396.91], ['5', 1479.98], ['t', 1567.98], ['6', 1661.22], ['y', 1760], ['7', 1864.66], ['u', 1975.53], ['i', 2093.00], ['9', 2217.46], ['o', 2349.32], ['0', 2489.02], ['p', 2637.02], ['[', 2793.83], ['=', 2959.96], [']', 3135.96]];
    this.keysDown = [];
    // bind a keyevent for each note
    return $.each(notes, function(k, v) {
      var key;
      // change numbers and chars to text
      key = v[0];
      switch (key) {
        case ',':
          key = 'comma';
          break;
        case '.':
          key = 'period';
          break;
        case ';':
          key = 'semicolon';
          break;
        case '/':
          key = 'slash';
          break;
        case '2':
          key = 'two';
          break;
        case '3':
          key = 'three';
          break;
        case '5':
          key = 'five';
          break;
        case '6':
          key = 'six';
          break;
        case '7':
          key = 'seven';
          break;
        case '0':
          key = 'zero';
          break;
        case '[':
          key = 'leftbracket';
          break;
        case '=':
          key = 'equals';
          break;
        case ']':
          key = 'rightbracket';
      }
      // attach click events to the keyboard to trigger notes
      $(`#${key}`).click(function(e) {
        e.preventDefault();
        return note(v[1]);
      });
      // keydown
      Mousetrap.bind(v[0], function(e) {
        // run if this key isn't already down
        if ($.inArray(e.keyIdentifier, this.keysDown) === -1) {
          this.keysDown.push(e.keyIdentifier);
          // play the note
          note(v[1]);
          // highlight the note
          return $(`#${key}`).addClass('active');
        }
      });
      // keyup
      return Mousetrap.bind(v[0], function(e) {
        // remove the key you let go of
        this.keysDown = _.without(this.keysDown, e.keyIdentifier);
        if (this.keysDown.length === 0) {
          // trigger the decay
          noteOff();
        }
        // unhighlight the note
        return $(`#${key}`).removeClass('active');
      }, 'keyup');
    });
  };

}).call(this);
