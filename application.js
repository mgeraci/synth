// Generated by CoffeeScript 1.3.3
(function() {
  var adsr, controlWatchers, init, oscillator, setDefaults;

  $(function() {
    init();
    return $('button').click(function() {
      return adsr();
    });
  });

  init = function() {
    try {
      this.context = new webkitAudioContext();
    } catch (error) {
      alert('Web Audio API is not supported in your browser');
    }
    if (this.context) {
      oscillator();
      controlWatchers();
      return setDefaults();
    }
  };

  controlWatchers = function() {
    var _this = this;
    $('#attack').on('change', function(e) {
      return _this.a = (500 * $(e.target).val()) / 100;
    });
    $('#decay').on('change', function(e) {
      return _this.d = (500 * $(e.target).val()) / 100;
    });
    $('#sustain').on('change', function(e) {
      return _this.s = (500 * $(e.target).val()) / 100;
    });
    $('#release').on('change', function(e) {
      return _this.r = (500 * $(e.target).val()) / 100;
    });
    $('#sustain-level').on('change', function(e) {
      return _this.sl = $(e.target).val() / 100;
    });
    return $('#wave').on('change', function(e) {
      var span, wave;
      span = $(e.target).siblings('span');
      switch (parseInt($(e.target).val())) {
        case 0:
          wave = 0;
          span.text('sine');
          break;
        case 25:
          wave = 1;
          span.text('square');
          break;
        case 50:
          wave = 2;
          span.text('saw');
          break;
        case 75:
          wave = 3;
          span.text('triangle');
      }
      return _this.osc.type = wave;
    });
  };

  setDefaults = function() {
    $('#attack').val(10).trigger('change');
    $('#decay').val(20).trigger('change');
    $('#sustain').val(100).trigger('change');
    $('#release').val(60).trigger('change');
    return $('#sustain-level').val(50).trigger('change');
  };

  oscillator = function() {
    this.osc = this.context.createOscillator();
    this.gainnode = this.context.createGainNode();
    this.osc.connect(this.gainnode);
    this.gainnode.gain.value = 0;
    this.gainnode.connect(context.destination);
    this.osc.noteOn(0);
    return this.osc.frequency.value = 500;
  };

  adsr = function() {
    var aNumberOfSteps, aSizeOfSteps, dNumberOfSteps, dSizeOfSteps, grain, i, output, rNumberOfSteps, rSizeOfSteps, _i,
      _this = this;
    grain = 1;
    output = 0;
    if (this.aInnerTimeout != null) {
      clearTimeout(this.aInnerTimeout);
    }
    if (this.dTimeout != null) {
      clearTimeout(this.dTimeout);
    }
    if (this.dInnerTimeout != null) {
      clearTimeout(this.dInnerTimeout);
    }
    if (this.rTimeout != null) {
      clearTimeout(this.rTimeout);
    }
    if (this.rInnerTimeout != null) {
      clearTimeout(this.rInnerTimeout);
    }
    if (this.endTimeout != null) {
      clearTimeout(this.endTimeout);
    }
    aNumberOfSteps = this.a / grain;
    aSizeOfSteps = 1 / aNumberOfSteps;
    dNumberOfSteps = this.d / grain;
    dSizeOfSteps = (1 - this.sl) / dNumberOfSteps;
    rNumberOfSteps = this.r / grain;
    rSizeOfSteps = this.sl / rNumberOfSteps;
    for (i = _i = 0; 0 <= aNumberOfSteps ? _i < aNumberOfSteps : _i > aNumberOfSteps; i = 0 <= aNumberOfSteps ? ++_i : --_i) {
      this.aInnerTimeout = setTimeout(function() {
        output += aSizeOfSteps;
        return _this.gainnode.gain.value = output;
      }, i * grain);
    }
    this.dTimeout = setTimeout(function() {
      var _j, _results;
      _results = [];
      for (i = _j = 0; 0 <= dNumberOfSteps ? _j < dNumberOfSteps : _j > dNumberOfSteps; i = 0 <= dNumberOfSteps ? ++_j : --_j) {
        _results.push(_this.dInnerTimeout = setTimeout(function() {
          output -= dSizeOfSteps;
          return _this.gainnode.gain.value = output;
        }, i * grain));
      }
      return _results;
    }, this.a);
    this.rTimeout = setTimeout(function() {
      var _j, _results;
      _results = [];
      for (i = _j = 0; 0 <= rNumberOfSteps ? _j < rNumberOfSteps : _j > rNumberOfSteps; i = 0 <= rNumberOfSteps ? ++_j : --_j) {
        _results.push(_this.rInnerTimeout = setTimeout(function() {
          output -= rSizeOfSteps;
          return _this.gainnode.gain.value = output;
        }, i * grain));
      }
      return _results;
    }, this.a + this.d + this.s);
    return this.endTimeout = setTimeout(function() {
      output = 0;
      return _this.gainnode.gain.value = output;
    }, this.a + this.d + this.s + this.r + grain * 2);
  };

}).call(this);
